{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Stellar SDK for Scala"},{"location":"/index.html#stellar-sdk-for-scala","text":"This is the SDK for performing Stellar operations via Scala. It provides the ability to access the Stellar network via Horizon instances to build and submit transactions, query the state of the network and stream updates.\nScala developers may prefer to use this SDK because it provides a more natural API for Scala developers than the official Java SDK\nThe code throughout this documentation is compiled against Scala 2.13.","title":"Stellar SDK for Scala"},{"location":"/index.html#quick-start","text":"Add the jitpack resolver.\nresolvers += \"jitpack\" at \"https://jitpack.io\"\nThen, add the SDK via your dependency management tool.\nsbt libraryDependencies += \"io.github.synesso\" %% \"scala-stellar-sdk\" % \"0.21.1\" Maven <dependencies>\n  <dependency>\n    <groupId>io.github.synesso</groupId>\n    <artifactId>scala-stellar-sdk_2.13</artifactId>\n    <version>0.21.1</version>\n  </dependency>\n</dependencies> Gradle dependencies {\n  implementation \"io.github.synesso:scala-stellar-sdk_2.13:0.21.1\"\n}\nCreating an account on the public test network.\ncopysourceval kp = KeyPair.random\nval response = TestNetwork.fund(kp)\nFetching the details of an account.\ncopysourceval account: Future[Account] = network.account(kp).map(_.toAccount)\nval nextSeqNo: Future[Long] = account.map(_.sequenceNumber)\nSubmitting a payment.\ncopysourcefor {\n  sourceAccount <- network.account(payerKeyPair)\n  response <- model.Transaction(sourceAccount, timeBounds = Unbounded, maxFee = NativeAmount(100))\n    .add(PaymentOperation(payeePublicKey.toAccountId, lumens(5000)))\n    .sign(payerKeyPair)\n    .submit()\n} yield response\nFor more detailed coverage, continue by reading about KeyPairs.","title":"Quick-start"},{"location":"/index.html#api","text":"Please enjoy the scaladoc for this release.\nDeprecation warning At this stage, classes and interfaces are likely to be refined. Minor releases may break backwards compatibility with minimal notice until v1.0.0.\nCheck the CHANGELOG for details of breaking changes.","title":"API"},{"location":"/index.html#contributing","text":"Contributions are warmly welcomed. Please feel free to contribute by reporting issues you find, or by suggesting changes to the code. Or feel free to add your own features/issues to that list.\nYou can contact me on KeyBase.","title":"Contributing"},{"location":"/transacting.html","text":"","title":"Transacting"},{"location":"/transacting.html#transacting","text":"Transactions are how changes such as payments, offers to trade or account creation are made to the network’s ledger.","title":"Transacting"},{"location":"/transacting.html#creating","text":"Every transaction must originate from an existing account on the network and correctly specify the next sequence number. Creating a new Transaction instance requires these two values, wrapped in an .\nAdditionally, a Network must be implicit in scope. The choice of network will affect how the transaction is serialised.\ncopysourceimplicit val network = TestNetwork\nval account = Account(AccountId(accn.publicKey), sequence)\nTransaction(account, maxFee = NativeAmount(100), timeBounds = TimeBounds.Unbounded)","title":"Creating"},{"location":"/transacting.html#sequence-number","text":"The sequence number for a new account is the id of the ledger in which is was created. The id increments by one with every submitted transaction. In simple architectures, it is possible to keep track of the next sequence number without querying the network. However, if this is not possible, or the number is unknown, you can directly substitute the response from the account query into the Transaction constructor.\ncopysourcefor {\n  sourceAccount <- network.account(payerKeyPair)\n  response <- model.Transaction(sourceAccount, timeBounds = Unbounded, maxFee = NativeAmount(100))\n    .add(PaymentOperation(payeePublicKey.toAccountId, lumens(5000)))\n    .sign(payerKeyPair)\n    .submit()\n} yield response\nAs this example shows, transactions require additional data before they can be successfully processed.","title":"Sequence Number"},{"location":"/transacting.html#operations","text":"Without any s, a transaction is not very useful. There can be as few as one and as many and one hundred operations added to each Transaction. These can be provided when constructing the Transaction.\ncopysourceval account = Account(sourceKey.toAccountId, nextSequenceNumber)\nval txn = Transaction(account, List(\n  CreateAccountOperation(aliceKey.toAccountId),\n  CreateAccountOperation(bobKey.toAccountId),\n  PaymentOperation(charlieKey.toAccountId, Amount.lumens(42))\n), timeBounds = Unbounded, maxFee = NativeAmount(100))\nOr they can be added afterwards.\ncopysourceval txn = Transaction(account, timeBounds = Unbounded, maxFee = NativeAmount(100))\n  .add(PaymentOperation(aliceKey.toAccountId, Amount.lumens(100)))\n  .add(PaymentOperation(bobKey.toAccountId, Amount.lumens(77)))\n  .add(PaymentOperation(charlieKey.toAccountId, Amount.lumens(4.08)))\n  .add(CreateSellOfferOperation(\n    selling = Amount.lumens(100),\n    buying = Asset(\"FRUITCAKE42\", aliceKey),\n    price = Price(100, 1)\n  ))\nThe available operations are:\nOperations need not originate from the same account as the transaction. In this way a single transaction can be issued that affects multiple accounts. This enables techniques such as the channel pattern. Each operation has an optional constructor parameter sourceAccount: Option[PublicKey] where the source account can be specified.","title":"Operations"},{"location":"/transacting.html#timebounds","text":"As of v0.9.0, the valid date range for a transaction must be specified. The network will reject any transaction submitted outside of the range defined. To help define TimeBounds, the object contains the constant Unbounded (representing all time) and the method timeout, which will return a TimeBound from the current time until some given timeout duration in the future.","title":"TimeBounds"},{"location":"/transacting.html#maximum-fee","text":"As of v0.9.0, the maximum fee payable must be specified explicitly. The network will reject the transaction if the maximum fee is not at least 100 stroops x number of operations. If accepted the actual fee charged will be the cheapest it can be, given current network demand but will never exceed the specified maximum fee. If the maximum fee is too low for the network’s demand at time of submission, the transaction will not be accepted.","title":"Maximum Fee"},{"location":"/transacting.html#signatures","text":"Before a transaction will be accepted by the network, it must be signed with at least one key. In the most basic case, the transaction only needs to be signed by the source account. This is done by calling .sign(KeyPair).\ncopysourceval transaction = Transaction(account, timeBounds = Unbounded, maxFee = NativeAmount(100)).add(operation)\nval signedTransaction: SignedTransaction = transaction.sign(sourceKey.publicKey)\nIt may be that the source account has been modified to require more than one signature. Or, as mentioned earlier, one or more of the operations may affect other accounts. In either of these cases, the transaction will not be valid until it has received all necessary signatures.\ncopysourceval transaction = Transaction(jointAccount, timeBounds = Unbounded, maxFee = NativeAmount(100)).add(operation)\nval signedTransaction: SignedTransaction = transaction.sign(aliceKey, bobKey)\nAdditionally, a transaction will fail if it has too many signatures.\nFinally, a transaction may be signed with any arbitrary byte array in order to match a hash signer. See Hash(x) signing for a summary.","title":"Signatures"},{"location":"/transacting.html#submitting","text":"Once a transaction is signed (and therefore is of type SignedTransaction) it can be submitted to the network.\ncopysourceval transaction = Transaction(account, timeBounds = Unbounded, maxFee = NativeAmount(100)).add(operation).sign(sourceKey)\nval response: Future[TransactionPostResponse] = transaction.submit()\nThe eventual resulting contains metadata about the processed transaction, including the full results encoded as XDR. Additionally, the XDR can be decoded on the fly by calling the relevant convenience methods.\ncopysourceTransaction(account, timeBounds = Unbounded, maxFee = NativeAmount(100)).add(operation).sign(sourceKey).submit().foreach {\n  case ok: TransactionApproved => println(ok.feeCharged)\n  case ko => println(ko)\n}","title":"Submitting"},{"location":"/transacting.html#xdr","text":"Transactions can be serialized to a base64-encoding of their XDR form. This is a strictly-defined format for transactions that is compatible across all supporting Stellar libraries and tooling. Given this, it is possible to save and load transaction state via XDR strings.\ncopysource //      txn mustEqual Transaction.decodeXdr(txn.xdr)\n\n//      txn.xdr.encode() mustEqual ByteString.decodeBase64(txn.encodeXdrString)\n\n      val encoded: String = txn.encodeXdrString\n      val decoded: Transaction = Transaction.decodeXdrString(encoded)\n      decoded must beEquivalentTo(txn)\nTransactions with signatures are a different data structure (signatures are included in an envelope along with the transaction) and need to be decoded via a similar method on SignedTransaction.\ncopysourceval encoded: String = signedTxn.encodeXDR\nval decoded: SignedTransaction = SignedTransaction.decodeXDR(encoded)\ndecoded must beEquivalentTo(signedTxn)","title":"XDR"},{"location":"/transacting.html#meta-data","text":"All transaction post and history responses include an XDR payload that describes the effects that the transaction had on the ledger. The field resultMetaXDR is the base64-encoded XDR payload. The method ledgerEntries will decode the payload into an instance of .\nSimilarly, the ledger effect of the fees is made available via the feeMetaXDR field and the feeLedgerEntries method.\nContinue reading to learn how to obtain historical data from network via Queries.","title":"Meta Data"},{"location":"/key_pairs.html","text":"","title":"Key Pairs"},{"location":"/key_pairs.html#key-pairs","text":"Accounts in Stellar are identified by a cryptographic key pair.\nThe public key, also known as the account id, can safely be shared with anybody. It is 52 characters long and begins with a G.\nThe private key, referred to as the secret seed, should be kept private & secure. It is also 52 characters long, but begins with an S.\nFor example, the following is a randomly generated account key pair. (This is an example only, do not use this.)\nAccount id:  GD2HMF3BKITMXISCPTU7VVTFXDY5WSQK4QNIUATNCXVKBNWZP7FWZOXG\nSecret Seed: SDHXK2UNHTXVW2MZSOVOPYUKVXD3PEVKMNQZZGPODQMR67YTKWMOC732\nThe knowledge of a key pair does not imply that the account exists on any Stellar network. In other words, when you call KeyPair.random, this does not create an account. To do that, you need to issue a transaction that contains a CreateAccountOperation, as explained in Transacting.\nThere are actually two kinds of KeyPair objects in the SDK.\nrepresents the public and secret components, and can be used for operations that require proof of the secret portion, such as transaction signing. represents only the public component. This is used to refer to accounts other than your own, such as the counterparty of a payment.\nAs the account id can be derived from the secret seed, there is no object which models the secret seed without the account id.\nThe SDK provides several ways to create or resolve KeyPairs and PublicKeys.","title":"Key Pairs"},{"location":"/key_pairs.html#randomly","text":"A random KeyPair is generated when you call KeyPair.random.\ncopysourceKeyPair.random\nThe chance of receiving a key pair that has been seen before is so miniscule that you might reasonably assume that any randomly generated pair is effectively unique.","title":"Randomly"},{"location":"/key_pairs.html#by-key","text":"If you know the secret seed (private key), then you can reconstitute the KeyPair.\ncopysource// Provide the secret seed as a String\nval keyPair = KeyPair.fromSecretSeed(\n  \"SDHXK2UNHTXVW2MZSOVOPYUKVXD3PEVKMNQZZGPODQMR67YTKWMOC732\")\n\n// or an Array[Char]\nKeyPair.fromSecretSeed(\n  \"SDHXK2UNHTXVW2MZSOVOPYUKVXD3PEVKMNQZZGPODQMR67YTKWMOC732\".toCharArray.toIndexedSeq)\n\n// or a raw 32 byte seed\nKeyPair.fromSecretSeed(\n  Hex.decodeHex(\"1123740522f11bfef6b3671f51e159ccf589ccf8965262dd5f97d1721d383dd4\")\n)\nIf you only know the account id (public key), you can create the PublicKey.\ncopysourceval accountId = \"GCXYKQF35XWATRB6AWDDV2Y322IFU2ACYYN5M2YB44IBWAIITQ4RYPXK\"\nval publicKey = KeyPair.fromAccountId(accountId)","title":"By Key"},{"location":"/key_pairs.html#by-passphrase","text":"As a substitute for a valid secret seed, any passphrase can be used to deterministically derive a KeyPair.\ncopysourceval kp = KeyPair.fromPassphrase(\n  \"But, the Babel fish is a dead giveaway isn't it?\"\n)","title":"By Passphrase"},{"location":"/key_pairs.html#by-federated-address","text":"As a convenience, accounts may also be identified by a human-readable address known as a Federated Address. These are in the format NAME*DOMAIN.\nFederated addresses can be resolved using the fromAddress method. Because the actual public key is retrieved from the network, this method returns a Future[PublicKey] and may fail.\ncopysourceval resolved: Future[PublicKey] = KeyPair.fromAddress(\"jem*keybase.io\")\nThat’s all you need to know about KeyPairs. Continue reading to learn about how to inspect Stellar networks via Queries.","title":"By Federated Address"},{"location":"/key_pairs.html#from-a-cryptographic-seed-phrase","text":"Keys can be restored from a mnemonic phrase and, optionally, a password.\ncopysourceval keyPair = KeyPair.fromMnemonicPhrase(\n  phrase = \"cable spray genius state float twenty onion head street palace net private \" +\n    \"method loan turn phrase state blanket interest dry amazing dress blast tube\",\n  passphrase = \"p4ssphr4se\".getBytes(\"UTF-8\"))\nkeyPair.accountId mustEqual \"GDAHPZ2NSYIIHZXM56Y36SBVTV5QKFIZGYMMBHOU53ETUSWTP62B63EQ\"\nMnemonic phrases are available in Chinese (simplified & traditional), Czech, English, French, Italian, Japanese, Korean and Spanish. Additional languages can be implemented in clients as needed. See\ncopysourceval keyPair = KeyPair.fromMnemonicPhrase(\n  phrase = \"つぶす　きそう　かるい　ようじ　なまいき　むさぼる　あこがれる　そっせん　みせる　しちょう　\" +\n    \"そんしつ　まろやか　しへい　さわやか　でんあつ　めした　せんとう　だっきゃく　ほっさ　ひるやすみ　\" +\n    \"はさみ　ようちえん　おんだん　えらい\",\n  wordList = JapaneseWords)\nkeyPair.accountId mustEqual \"GDEIRKSGFKJCCXUQAM2KVUOAFV626NESTZ5Q4FRCUXTTYHK6RTN66TY2\"\nYou can construct a new random mnemonic phrase with any supported language and 128-256 bits of entropy.\ncopysourceval mnemonic = Mnemonic.random(SpanishWords, entropyBits = 128)\nval passphrase = new ByteString(\"perro salchicha\".getBytes(UTF_8))\nval keyPair = mnemonic.asRootKeyPair(passphrase)\nKeyPair.fromMnemonic(mnemonic, passphrase, SpanishWords).accountId mustEqual keyPair.accountId\n(If you wish to use your own source of entropy, rather than rely on the JVM, you can do that via the method Mnemonic.fromEntropy.)","title":"From a cryptographic seed phrase"},{"location":"/key_pairs.html#more-on-mnemonics","text":"Mnemonic phrases derive cryptographic seeds which are the the root of a vast tree of deterministic addresses. If you wish to do more than map a phrase to a KeyPair, then you should access the HDNode of the Mnemonic. From any node, you can derive the child nodes to any depth.\ncopysourceval mnemonic = Mnemonic.random(FrenchWords)\nval passphrase = new ByteString(\"chien saucisse\".getBytes(UTF_8))\nval rootNode = mnemonic.asHDNode(passphrase)\nval node = rootNode.deriveChild(33, 18, 193, 4)\nnode.privateKey mustEqual rootNode\n  .deriveChild(33)\n  .deriveChild(18)\n  .deriveChild(193)\n  .deriveChild(4)\n  .privateKey\nNote that the subtree of nodes 44/148/0 are dedicated to Stellar keys and can be accessed by the KeyPair deriving methods on both KeyPair and Mnemonic.","title":"More on mnemonics"},{"location":"/queries.html","text":"","title":"Queries"},{"location":"/queries.html#queries","text":"A convenient HTTP API for accessing Stellar is provided by the Stellar Development Foundation (SDF) through a component called Horizon. The Scala Stellar SDK provides access to these endpoints via methods on the interface. These methods mirror the REST API provided by Horizon.\nThe SDF supports two main networks, the primary public network and another for testing. These are represented separately by the objects PublicNetwork and TestNetwork.\nIf it is your use-case that you are deploying a separate, private Stellar network, then you can implement the Network trait to provide access to the Horizon endpoints on your network.\nQueries fall into several categories.","title":"Queries"},{"location":"/queries.html#accounts","text":"s are the entities through which users can interact with the network. They are represented by a key pair. Account details can be found given an account’s or .\ncopysourceval accountId = \"GCXYKQF35XWATRB6AWDDV2Y322IFU2ACYYN5M2YB44IBWAIITQ4RYPXK\"\nval publicKey = KeyPair.fromAccountId(accountId)\n\n// account details\nval accountDetails: Future[AccountResponse] = TestNetwork.account(publicKey)\n\n// account datum value\nval accountData: Future[Array[Byte]] = TestNetwork.accountData(publicKey, \"data_key\")","title":"Accounts"},{"location":"/queries.html#assets","text":"s are the items that are traded on the network. They can be searched for by their code, issuer, neither or both.\nBy default the results will be in ascending order from the earliest record. This behaviour can be modified with the cursor and order parameters.\ncopysource// stream of all assets from all issuers\nval allAssets: Future[LazyList[AssetResponse]] = TestNetwork.assets()\n\n// stream of the last 20 assets created\nval last20Assets =\n  TestNetwork.assets(cursor = Now, order = Desc).map(_.take(20))\n\n// stream of assets with the code HUG\nval hugAssets: Future[LazyList[AssetResponse]] = TestNetwork.assets(code = Some(\"HUG\"))\n\n// stream of assets from the specified issuer\nval issuerAssets: Future[LazyList[AssetResponse]] =\n  TestNetwork.assets(issuer = Some(publicKey))\n\n// LazyList (of max length 1) of HUG assets from the issuer\nval issuersHugAsset: Future[LazyList[AssetResponse]] =\n  TestNetwork.assets(code = Some(\"HUG\"), issuer = Some(publicKey))","title":"Assets"},{"location":"/queries.html#effects","text":"s are the changes that have been effected on the network as a result of operations successfully processed.\nBy default the results will be in ascending order from the earliest record. This behaviour can be modified with the cursor and order parameters.\ncopysource// stream of all effects\nval allEffects: Future[LazyList[EffectResponse]] = TestNetwork.effects()\n\n// stream of the last 20 effects\nval last20Effects =\n  TestNetwork.effects(cursor = Now, order = Desc).map(_.take(20))\n\n// stream of effects related to a specific account\nval effectsForAccount = TestNetwork.effectsByAccount(publicKey)\n\n// stream of effects related to a specific transaction hash\nval effectsForTxn: Future[LazyList[EffectResponse]] =\n  TestNetwork.effectsByTransaction(\"f00cafe...\")\n\n// stream of effects related to a specific operation id\nval effectsForOperationId: Future[LazyList[EffectResponse]] =\n  TestNetwork.effectsByOperation(123L)\n\n// stream of effects for a specific ledger\nval effectsForLedger = TestNetwork.effectsByLedger(1234)","title":"Effects"},{"location":"/queries.html#fee-statistics","text":"When transacting, it is possible to nominate a fee that is greater than the base fee. Transactions paying higher fees are prioritised at times of high load.\nThis parameterless endpoint provides statistics about the fees paid during the last known ledger.\ncopysourceval feeStats: Future[FeeStatsResponse] = TestNetwork.feeStats()\nval minAcceptedFee: Future[NativeAmount] = feeStats.map(_.chargedFees.min)\nval percentileFee99: Future[NativeAmount] =\n  feeStats.map(_.chargedFees.percentiles(99))","title":"Fee Statistics"},{"location":"/queries.html#ledgers","text":"s represent the state of the network at any time. They are created sequentially as the state of the network changes.\nIt is possible to stream all ledgers or query for a specific ledger by its sequential id. Each returned value provides meta-data about the changes in that ledger, as well as a summary of the network at that point of time.\nBy default the results will be in ascending order from the earliest record. This behaviour can be modified with the cursor and order parameters.\ncopysource// details of a specific ledger\nval ledger: Future[LedgerResponse] = TestNetwork.ledger(1234)\n\n// stream of all ledgers\nval ledgers: Future[LazyList[LedgerResponse]] = TestNetwork.ledgers()\n\n// stream of the last 20 ledgers\nval last20Ledgers =\n  TestNetwork.ledgers(cursor = Now, order = Desc).map(_.take(20))","title":"Ledgers"},{"location":"/queries.html#network-info","text":"Meta information about the network itself is available via the info() endpoint. Data provided in the response includes the network passphrase, software versions for Horizon and Core, the current and max supported core protocol versions, and the earliest and latest ledger ids.\ncopysourceval info: Future[NetworkInfo] = TestNetwork.info()\nval passphrase: Future[String] = info.map(_.passphrase)","title":"Network Info"},{"location":"/queries.html#offers","text":"s can be issued by accounts to buy or sell assets. Querying for offers is available only by account. Additional offers are found by searching the OrderBook.\nBy default the results will be in ascending order from the earliest record. This behaviour can be modified with the cursor and order parameters.\ncopysource// all offers for a specified account\nval offersByAccount: Future[LazyList[OfferResponse]] =\n  TestNetwork.offersByAccount(publicKey)\n\n// most recent offers from a specified account\nval last20Offers = TestNetwork\n  .offersByAccount(publicKey, order = Desc, cursor = Now).map(_.take(20))","title":"Offers"},{"location":"/queries.html#operations","text":"s are changes to the ledger. They represent the action, as opposed to the effects resulting from the action.\nOperations returned by these queries are wrapped in the type. This indicates that the operation has been part of a successful transaction, and provides details about that transaction.\nBy default the results will be in ascending order from the earliest record. This behaviour can be modified with the cursor and order parameters.\nThere are several ways to search for and filter operations.\ncopysource// details of a specific operation\nval operation: Future[Transacted[Operation]] = TestNetwork.operation(1234)\n\n// stream of all operations\nval operations: Future[LazyList[Transacted[Operation]]] = TestNetwork.operations()\n\n// stream of operations from a specified account\nval opsForAccount: Future[LazyList[Transacted[Operation]]] =\n  TestNetwork.operationsByAccount(publicKey)\n\n// stream of operations from a specified ledger\nval opsForLedger: Future[LazyList[Transacted[Operation]]] =\n  TestNetwork.operationsByLedger(1234)\n\n// stream of operations from a transaction specified by its hash\nval opsForTxn: Future[LazyList[Transacted[Operation]]] =\n  TestNetwork.operationsByTransaction(\"f00cafe...\")","title":"Operations"},{"location":"/queries.html#orderbook","text":"s include all the offers to buy or sell a specific asset. They show the depth limited to the value of the limit param, which defaults to 20.\ncopysource// the XLM/HUG orderbook with up to 20 offers\nval hugOrderBook: Future[OrderBook] = TestNetwork.orderBook(\n  selling = NativeAsset,\n  buying = Asset(\"HUG\", publicKey)\n)\n\n// the FabulousBeer/HUG orderbook with up to 100 offers\nval beerForHugsBigOrderBook: Future[OrderBook] =\n  TestNetwork.orderBook(\n    selling = Asset(\"FabulousBeer\", publicKey),\n    buying = Asset(\"HUG\", publicKey),\n    limit = 100\n  )","title":"OrderBook"},{"location":"/queries.html#payments","text":"s are the subset of Operations that cause payments to be made to an account. This is similar to the Operations query methods, but will only return CreateAccount and Payment operations.\nBy default the results will be in ascending order from the earliest record. This behaviour can be modified with the cursor and order parameters.\ncopysource// stream of all payment operations\nval payments: Future[LazyList[Transacted[PayOperation]]] = TestNetwork.payments()\n\n// stream of payment operations involving a specified account\nval accountPayments = TestNetwork.paymentsByAccount(publicKey)\n\n// stream of payment operations in a specified ledger\nval ledgerPayments = TestNetwork.paymentsByLedger(1234)\n\n// stream of payment operations in a specified transaction\nval transactionPayments = TestNetwork.paymentsByTransaction(\"bee042...\")","title":"Payments"},{"location":"/queries.html#payment-paths","text":"In order for a cross-token payment to find the most cost-efficient path through the offers in the distributed ledger, it is necessary to query the network for the available pathways, given the current orderbooks.\ns document the source & destination amounts - along with any intermediate assets that would fulfil a path payment.","title":"Payment Paths"},{"location":"/queries.html#trades","text":"s are created when offers in an orderbook are partially or fully matched.\nBy default the results will be in ascending order from the earliest record. This behaviour can be modified with the cursor and order parameters.\ncopysource// stream of all trades\nval trades: Future[LazyList[Trade]] = TestNetwork.trades()\n\n// stream of trades belonging to a specified orderbook\nval orderBookTrades: Future[LazyList[Trade]] = TestNetwork.tradesByOrderBook(\n  base = NativeAsset,\n  counter = Asset(\"HUG\", publicKey)\n)\n\n// stream of trades that are created as a result of the specified offer\nval offerBookTrades: Future[LazyList[Trade]] = TestNetwork.tradesByOfferId(1234)","title":"Trades"},{"location":"/queries.html#trade-aggregations","text":"s are summaries of historical trade data for a given asset pair, time period and time resolution.\nBy default the results will be in ascending order from the earliest record. This behaviour can be modified with the cursor and order parameters.\ncopysource// stream of all trades\nval trades: Future[LazyList[Trade]] = TestNetwork.trades()\n\n// stream of trades belonging to a specified orderbook\nval orderBookTrades: Future[LazyList[Trade]] = TestNetwork.tradesByOrderBook(\n  base = NativeAsset,\n  counter = Asset(\"HUG\", publicKey)\n)\n\n// stream of trades that are created as a result of the specified offer\nval offerBookTrades: Future[LazyList[Trade]] = TestNetwork.tradesByOfferId(1234)","title":"Trade Aggregations"},{"location":"/queries.html#transactions","text":"By default the results will be in ascending order from the earliest record. This behaviour can be modified with the cursor and order parameters.\nTransactions are the fundamental unit of change in the network and are composed of at least one and at most 100 operations. These queries return validated transactions, in the form of responses (as opposed to transactions that are composed and submitted to the network).\ncopysource// details of a specific transaction\nval transaction: Future[TransactionHistory] =\n  TestNetwork.transaction(transactionIdString)\n\n// stream of all transactions\nval transactions: Future[LazyList[TransactionHistory]] =\n  TestNetwork.transactions()\n\n// stream of transactions affecting the specified account\nval accountTxns = TestNetwork.transactionsByAccount(publicKey)\n\n// stream of transactions within the specified ledger\nval ledgerTxns = TestNetwork.transactionsByLedger(1234)\nContinue reading to learn how to subscribe and respond to future events via Sources.","title":"Transactions"},{"location":"/sources.html","text":"","title":"Sources"},{"location":"/sources.html#sources","text":"Many of the of the APIs made available via Queries are also available in a streaming mode. Access to the streaming endpoints is made available on the interface by way of *Source methods. Whereas queries provide access to historical data, sources can be used to subscribe to updates from the network in near real-time.\nSources are a concept native to Akka Streams. They provide resilient access to upstream data and support backpressure should the data be arriving faster than the application is capable of processing.\nBefore sources can be used, an actor system and materializer need to be brought into implicit scope.\ncopysource//  implicit val system = ActorSystem(\"stellar-sources\")\n//  implicit val materializer = ActorMaterializer()\n  import scala.concurrent.ExecutionContext.Implicits.global\nOnce done, sources may be used as a method for subscribing to updates. For example:\ncopysource      // print each new transaction's hash\n//      TestNetwork.transactionSource().runForeach(txn => println(txn.hash))\n\n      // a source of transactions for a given account\n//      val accnTxnSource: Source[TransactionHistory, NotUsed] =\n//        TestNetwork.transactionsByAccountSource(publicKey)\n\n      // a source of transactions for ledger #3,\n      // started from the beginning of time to ensure we get everything\n//      val ledgerTxnSource = TestNetwork.transactionsByLedgerSource(1, Record(0))\nLike queries, sources fall into several categories.","title":"Sources"},{"location":"/sources.html#effects","text":"s are the changes that have been effected on the network as a result of operations successfully processed.\ncopysource      // a source of all new effects\n//      val effectsSource: Source[EffectResponse, NotUsed] = TestNetwork.effectsSource()\n\n      // a source of all new effects for a given account\n//      val effectsForAccountSource = TestNetwork.effectsByAccountSource(publicKey)","title":"Effects"},{"location":"/sources.html#ledgers","text":"s represent the state of the network at any time. They are created sequentially as the state of the network changes.\ncopysource      // a source of all new ledgers\n//      val ledgersSource: Source[LedgerResponse, NotUsed] = TestNetwork.ledgersSource()","title":"Ledgers"},{"location":"/sources.html#offers","text":"s can be issued by accounts to buy or sell assets. Sources for offers is available only by account.\ncopysource//      val offersByAccountSource: Source[OfferResponse, NotUsed] =\n//        TestNetwork.offersByAccountSource(publicKey)","title":"Offers"},{"location":"/sources.html#operations","text":"s are changes to the ledger. They represent the action, as opposed to the effects resulting from the action.\nOperations returned by these queries are wrapped in the type. This indicates that the operation has been part of a successful transaction, and provides details about that transaction.\ncopysource      // a source of all new operations\n//      val operationsSource: Source[Transacted[Operation], NotUsed] = TestNetwork.operationsSource()\n\n      // a source of all new operations involving a specified account\n//      val operationsByAccountSource = TestNetwork.operationsByAccountSource(publicKey)","title":"Operations"},{"location":"/sources.html#orderbooks","text":"s include all the offers to buy or sell a specific asset. The source for an orderbook will present offers for that pair.\ncopysource//      val beerForHugsBigOrderBookSource: Source[OrderBook, NotUsed] =\n//        TestNetwork.orderBookSource(\n//          selling = Asset(\"FabulousBeer\", publicKey),\n//          buying = Asset(\"HUG\", publicKey),\n//        )","title":"OrderBooks"},{"location":"/sources.html#payments","text":"s are the subset of Operations that cause payments to be made to an account. This is similar to the Operations query methods, but will only return CreateAccount and Payment operations.\ncopysource      // a source of all new payment operations\n//      val paymentsSource: Source[Transacted[PayOperation], NotUsed] = TestNetwork.paymentsSource()\n\n      // a source of all new payment operations involving a specified account\n//      val paymentsByAccountSource = TestNetwork.paymentsByAccountSource(publicKey)","title":"Payments"},{"location":"/sources.html#transactions","text":"Transactions are the fundamental unit of change in the network and are composed of at least one and at most 100 operations. These sources stream validated transactions, in the form of responses (as opposed to transactions that are composed and submitted to the network).\ncopysource      // print each new transaction's hash\n//      TestNetwork.transactionSource().runForeach(txn => println(txn.hash))\n\n      // a source of transactions for a given account\n//      val accnTxnSource: Source[TransactionHistory, NotUsed] =\n//        TestNetwork.transactionsByAccountSource(publicKey)\n\n      // a source of transactions for ledger #3,\n      // started from the beginning of time to ensure we get everything\n//      val ledgerTxnSource = TestNetwork.transactionsByLedgerSource(1, Record(0))\nContinue reading to learn how to query for information on organizations that use the Stellar network via Domains.","title":"Transactions"},{"location":"/domains.html","text":"","title":"Domains"},{"location":"/domains.html#domains","text":"Any domain with an interest in the Stellar network can publish their network information on their website. This format is defined by SEP-0001 and is both human and machine readable.\nThe SDK can parse all known fields as per v2.0.0 of the specification.\ncopysourceDomainInfo.forDomain(\"stellar.org\") must beSome(\n  DomainInfo(\n    version = Some(\"2.0.0\"),\n    accounts = List(\n      KeyPair.fromAccountId(\"GB6NVEN5HSUBKMYCE5ZOWSK5K23TBWRUQLZY3KNMXUZ3AQ2ESC4MY4AQ\"),\n      KeyPair.fromAccountId(\"GATL3ETTZ3XDGFXX2ELPIKCZL7S5D2HY3VK4T7LRPD6DW5JOLAEZSZBA\"),\n      KeyPair.fromAccountId(\"GCVLWV5B3L3YE6DSCCMHLCK7QIB365NYOLQLW3ZKHI5XINNMRLJ6YHVX\"),\n      KeyPair.fromAccountId(\"GCVJDBALC2RQFLD2HYGQGWNFZBCOD2CPOTN3LE7FWRZ44H2WRAVZLFCU\"),\n      KeyPair.fromAccountId(\"GAMGGUQKKJ637ILVDOSCT5X7HYSZDUPGXSUW67B2UKMG2HEN5TPWN3LQ\"),\n      KeyPair.fromAccountId(\"GDUY7J7A33TQWOSOQGDO776GGLM3UQERL4J3SPT56F6YS4ID7MLDERI4\"),\n      KeyPair.fromAccountId(\"GCPWKVQNLDPD4RNP5CAXME4BEDTKSSYRR4MMEL4KG65NEGCOGNJW7QI2\"),\n      KeyPair.fromAccountId(\"GDKIJJIKXLOM2NRMPNQZUUYK24ZPVFC6426GZAEP3KUK6KEJLACCWNMX\"),\n      KeyPair.fromAccountId(\"GAX3BRBNB5WTJ2GNEFFH7A4CZKT2FORYABDDBZR5FIIT3P7FLS2EFOZZ\"),\n      KeyPair.fromAccountId(\"GBEVKAYIPWC5AQT6D4N7FC3XGKRRBMPCAMTO3QZWMHHACLHTMAHAM2TP\"),\n      KeyPair.fromAccountId(\"GCKJZ2YVECFGLUDJ5T7NZMJPPWERBNYHCXT2MZPXKELFHUSYQR5TVHJQ\"),\n      KeyPair.fromAccountId(\"GBA6XT7YBQOERXT656T74LYUVJ6MEIOC5EUETGAQNHQHEPUFPKCW5GYM\"),\n      KeyPair.fromAccountId(\"GD2D6JG6D3V52ZMPIYSVHYFKVNIMXGYVLYJQ3HYHG5YDPGJ3DCRGPLTP\"),\n      KeyPair.fromAccountId(\"GA2VRL65L3ZFEDDJ357RGI3MAOKPJZ2Z3IJTPSC24I4KDTNFSVEQURRA\")\n    ),\n    issuerDocumentation = Some(IssuerDocumentation(\n      name = Some(\"Stellar Development Foundation\"),\n      url = Some(HttpUrl.parse(\"https://www.stellar.org\")),\n      github = Some(\"stellar\"),\n      twitter = Some(\"StellarOrg\"),\n    )),\n    validators = List(\n      Validator(\n        alias = Some(\"sdf1\"),\n        displayName = Some(\"SDF 1\"),\n        host = Some(\"core-live-a.stellar.org:11625\"),\n        publicKey = Some(KeyPair.fromAccountId(\"GCGB2S2KGYARPVIA37HYZXVRM2YZUEXA6S33ZU5BUDC6THSB62LZSTYH\")),\n        history = Some(HttpUrl.parse(\"http://history.stellar.org/prd/core-live/core_live_001/\"))\n      ),\n      Validator(\n        alias = Some(\"sdf2\"),\n        displayName = Some(\"SDF 2\"),\n        host = Some(\"core-live-b.stellar.org:11625\"),\n        publicKey = Some(KeyPair.fromAccountId(\"GCM6QMP3DLRPTAZW2UZPCPX2LF3SXWXKPMP3GKFZBDSF3QZGV2G5QSTK\")),\n        history = Some(HttpUrl.parse(\"http://history.stellar.org/prd/core-live/core_live_002/\"))\n      ),\n      Validator(\n        alias = Some(\"sdf3\"),\n        displayName = Some(\"SDF 3\"),\n        host = Some(\"core-live-c.stellar.org:11625\"),\n        publicKey = Some(KeyPair.fromAccountId(\"GABMKJM6I25XI4K7U6XWMULOUQIQ27BCTMLS6BYYSOWKTBUXVRJSXHYQ\")),\n        history = Some(HttpUrl.parse(\"http://history.stellar.org/prd/core-live/core_live_003/\"))\n      ),\n    )\n  )\n)\nThe domain info spec is rich with data about the organizations that use the Stellar network. It is worth bearing in mind that the document is not mandatory and can contain errors. Only fields that align with the SEP will be parsed.\nContinue reading to learn how to use Stellar transactions for authentication.","title":"Domains"},{"location":"/authentication.html","text":"","title":"Authentication"},{"location":"/authentication.html#authentication","text":"In SEP-0010 Stellar defines a mechanism for using the cryptographic properties of transactions in order to present and fulfil an authentication challenge.\nThe server constructs a challenge with an . The challenge can be serialised to and deserialised from JSON.\ncopysourceval challenge = authChallenger.challenge(clientKey.toAccountId, \"test.com\")\nChallenge(challenge.toJson) must beEquivalentTo(challenge)\nThe client can meet the challenge by signing the presented transaction. The server can then\ncopysourceval challenge = authChallenger.challenge(\n  accountId = clientKey.toAccountId,\n  homeDomain = \"test.com\",\n  timeout = 15.minutes\n)\nval answer = challenge.signedTransaction.sign(clientKey)\nchallenge.verify(answer) mustEqual ChallengeSuccess\nIt is important that the client validate the properties of the challenge transaction before signing and returning. For example, the transaction should have a sequence number of zero to prevent it from being submittable to the network. See the SEP-0010 specification for up-to-date requirements.","title":"Authentication"}]}
